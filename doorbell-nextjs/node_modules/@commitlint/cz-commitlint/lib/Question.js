"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const inquirer_1 = __importDefault(require("inquirer"));
class Question {
    constructor(name, { title, enumList, messages, defaultValue, when, skip, fullStopFn, caseFn, maxLength, minLength, multipleValueDelimiters, multipleSelectDefaultDelimiter, }) {
        if (!name || typeof name !== 'string')
            throw new Error('Question: name is required');
        this._maxLength = maxLength !== null && maxLength !== void 0 ? maxLength : Infinity;
        this._minLength = minLength !== null && minLength !== void 0 ? minLength : 0;
        this.messages = messages;
        this.title = title !== null && title !== void 0 ? title : '';
        this.skip = skip !== null && skip !== void 0 ? skip : false;
        this.fullStopFn = fullStopFn !== null && fullStopFn !== void 0 ? fullStopFn : ((_) => _);
        this.caseFn =
            caseFn !== null && caseFn !== void 0 ? caseFn : ((input, delimiter) => Array.isArray(input) ? input.join(delimiter) : input);
        this.multipleValueDelimiters = multipleValueDelimiters;
        this.multipleSelectDefaultDelimiter = multipleSelectDefaultDelimiter;
        if (enumList && Array.isArray(enumList)) {
            this._question = {
                type: multipleSelectDefaultDelimiter ? 'checkbox' : 'list',
                choices: skip
                    ? [
                        ...enumList,
                        new inquirer_1.default.Separator(),
                        {
                            name: 'empty',
                            value: '',
                        },
                    ]
                    : [...enumList],
            };
        }
        else if (/^is[A-Z]/.test(name)) {
            this._question = {
                type: 'confirm',
            };
        }
        else {
            this._question = {
                type: 'input',
                transformer: this.transformer.bind(this),
            };
        }
        Object.assign(this._question, {
            name,
            default: defaultValue,
            when,
            validate: this.validate.bind(this),
            filter: this.filter.bind(this),
            message: this.decorateMessage.bind(this),
        });
    }
    getMessage(key) {
        var _a;
        return (_a = this.messages[key]) !== null && _a !== void 0 ? _a : '';
    }
    get question() {
        return this._question;
    }
    get maxLength() {
        return this._maxLength;
    }
    set maxLength(maxLength) {
        this._maxLength = maxLength;
    }
    get minLength() {
        return this._minLength;
    }
    set minLength(minLength) {
        this._minLength = minLength;
    }
    beforeQuestionStart(_answers) {
        return;
    }
    validate(input) {
        var _a;
        const output = this.filter(input);
        const questionName = (_a = this.question.name) !== null && _a !== void 0 ? _a : '';
        if (!this.skip && output.length === 0) {
            return this.getMessage('emptyWarning').replace(/%s/g, questionName);
        }
        if (output.length > this.maxLength) {
            return this.getMessage('upperLimitWarning')
                .replace(/%s/g, questionName)
                .replace(/%d/g, `${output.length - this.maxLength}`);
        }
        if (output.length < this.minLength) {
            return this.getMessage('lowerLimitWarning')
                .replace(/%s/g, questionName)
                .replace(/%d/g, `${this.minLength - output.length}`);
        }
        return true;
    }
    filter(input) {
        let toCased;
        if (Array.isArray(input)) {
            toCased = this.caseFn(input, this.multipleSelectDefaultDelimiter);
        }
        else if (this.multipleValueDelimiters) {
            const segments = input.split(this.multipleValueDelimiters);
            const casedString = this.caseFn(segments, ',');
            const casedSegments = casedString.split(',');
            toCased = input.replace(new RegExp(`[^${this.multipleValueDelimiters.source}]+`, 'g'), (segment) => {
                return casedSegments[segments.indexOf(segment)];
            });
        }
        else {
            toCased = this.caseFn(input);
        }
        return this.fullStopFn(toCased);
    }
    transformer(input, _answers) {
        const output = this.filter(input);
        if (this.maxLength === Infinity && this.minLength === 0) {
            return output;
        }
        const color = output.length <= this.maxLength && output.length >= this.minLength
            ? chalk_1.default.green
            : chalk_1.default.red;
        return color('(' + output.length + ') ' + output);
    }
    decorateMessage(_answers) {
        this.beforeQuestionStart && this.beforeQuestionStart(_answers);
        if (this.question.type === 'input') {
            const countLimitMessage = (() => {
                const messages = [];
                if (this.minLength > 0 && this.getMessage('min')) {
                    messages.push(this.getMessage('min').replace(/%d/g, this.minLength + ''));
                }
                if (this.maxLength < Infinity && this.getMessage('max')) {
                    messages.push(this.getMessage('max').replace(/%d/g, this.maxLength + ''));
                }
                return messages.join(', ');
            })();
            const skipMessage = this.skip && this.getMessage('skip');
            return (this.title +
                (skipMessage ? ` ${skipMessage}` : '') +
                ':' +
                (countLimitMessage ? ` ${countLimitMessage}` : '') +
                '\n');
        }
        else {
            return `${this.title}:`;
        }
    }
}
exports.default = Question;
//# sourceMappingURL=Question.js.map