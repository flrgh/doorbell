"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineCommitMessage = exports.getQuestions = exports.FooterQuestion = void 0;
const word_wrap_1 = __importDefault(require("word-wrap"));
const Question_1 = __importDefault(require("./Question"));
const getRuleQuestionConfig_1 = __importDefault(require("./services/getRuleQuestionConfig"));
const prompts_1 = require("./store/prompts");
const rules_1 = require("./store/rules");
const leading_blank_fn_1 = __importDefault(require("./utils/leading-blank-fn"));
const rules_2 = require("./utils/rules");
class FooterQuestion extends Question_1.default {
    constructor(name, questionConfig, footerMaxLength, footerMinLength) {
        super(name, questionConfig);
        this.footerMaxLength = footerMaxLength !== null && footerMaxLength !== void 0 ? footerMaxLength : Infinity;
        this.footerMinLength = footerMinLength !== null && footerMinLength !== void 0 ? footerMinLength : 0;
    }
    beforeQuestionStart(answers) {
        const footerRemainLength = this.footerMaxLength - combineCommitMessage(answers).length - '\n'.length;
        this.maxLength = Math.min(this.maxLength, footerRemainLength);
        this.minLength = Math.min(this.minLength, this.footerMinLength);
    }
}
exports.FooterQuestion = FooterQuestion;
function getQuestions() {
    const footerQuestionConfig = (0, getRuleQuestionConfig_1.default)('footer');
    if (!footerQuestionConfig)
        return [];
    const footerMaxLength = footerQuestionConfig.maxLength;
    const footerMinLength = footerQuestionConfig.minLength;
    const fields = [
        'isBreaking',
        'breakingBody',
        'breaking',
        'isIssueAffected',
        'issuesBody',
        'issues',
        'footer',
    ];
    return fields
        .filter((name) => name in (0, prompts_1.getPromptQuestions)())
        .map((name) => {
        var _a, _b;
        const questions = (0, prompts_1.getPromptQuestions)();
        const questionConfigs = {
            title: (_b = (_a = questions[name]) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : '',
            messages: (0, prompts_1.getPromptMessages)(),
            footerMaxLength,
            footerMinLength,
        };
        if (name === 'isBreaking') {
            Object.assign(questionConfigs, {
                defaultValue: false,
            });
        }
        if (name === 'breakingBody') {
            Object.assign(questionConfigs, {
                when: (answers) => {
                    return answers.isBreaking && !answers.body;
                },
            });
        }
        if (name === 'breaking') {
            Object.assign(questionConfigs, {
                when: (answers) => {
                    return answers.isBreaking;
                },
            });
        }
        if (name === 'isIssueAffected') {
            Object.assign(questionConfigs, {
                defaultValue: false,
            });
        }
        if (name === 'issuesBody') {
            Object.assign(questionConfigs, {
                when: (answers) => {
                    return (answers.isIssueAffected && !answers.body && !answers.breakingBody);
                },
            });
        }
        if (name === 'issues') {
            Object.assign(questionConfigs, {
                when: (answers) => {
                    return answers.isIssueAffected;
                },
            });
        }
        if (name === 'footer') {
            Object.assign(questionConfigs, Object.assign({}, footerQuestionConfig));
        }
        const instance = new FooterQuestion(name, questionConfigs, footerMaxLength, footerMinLength);
        return instance.question;
    });
}
exports.getQuestions = getQuestions;
function combineCommitMessage(answers) {
    // TODO references-empty
    // TODO signed-off-by
    const maxLineLength = (0, rules_2.getMaxLength)((0, rules_1.getRule)('footer', 'max-line-length'));
    const leadingBlankFn = (0, leading_blank_fn_1.default)((0, rules_1.getRule)('footer', 'leading-blank'));
    const { footer, breaking, issues } = answers;
    const footerNotes = [];
    if (breaking) {
        const BREAKING_CHANGE = 'BREAKING CHANGE: ';
        const message = BREAKING_CHANGE + breaking.replace(new RegExp(`^${BREAKING_CHANGE}`), '');
        footerNotes.push(maxLineLength < Infinity
            ? (0, word_wrap_1.default)(message, {
                width: maxLineLength,
                trim: true,
                indent: '',
            })
            : message.trim());
    }
    if (issues) {
        footerNotes.push(maxLineLength < Infinity
            ? (0, word_wrap_1.default)(issues, {
                width: maxLineLength,
                trim: true,
                indent: '',
            })
            : issues.trim());
    }
    if (footer) {
        footerNotes.push(maxLineLength < Infinity
            ? (0, word_wrap_1.default)(footer, {
                width: maxLineLength,
                trim: true,
                indent: '',
            })
            : footer);
    }
    return leadingBlankFn(footerNotes.join('\n'));
}
exports.combineCommitMessage = combineCommitMessage;
//# sourceMappingURL=SectionFooter.js.map